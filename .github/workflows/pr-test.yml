# PR Test Environment Workflow - Triggered by PR events
#
# Each PR gets an isolated environment with its own DB/Redis/MinIO.
# Uses docker-compose.yml from this repo (not infra2).

name: PR Test Environment

on:
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches: [main]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR Number'
        required: true
      action:
        description: 'Action'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - cleanup

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}/finance_report
  DOKPLOY_API_URL: https://cloud.zitian.party/api
  TEST_ENV_ID: -fzh5EGJN74I1AjNEpVUr
  GITHUB_INTEGRATION_ID: 126refcRlCoWj6pmPXElU
  INTERNAL_DOMAIN: zitian.party

jobs:
  setup:
    name: Setup Variables
    runs-on: ubuntu-latest
    outputs:
      compose_name: ${{ steps.info.outputs.compose_name }}
      pr_number: ${{ steps.info.outputs.pr_number }}
      action: ${{ steps.info.outputs.action }}
      internal_domain: ${{ steps.info.outputs.internal_domain }}
    steps:
      - name: Determine Params
        id: info
        run: |
          echo "internal_domain=${{ env.INTERNAL_DOMAIN }}" >> $GITHUB_OUTPUT
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "Manual trigger for PR ${{ github.event.inputs.pr_number }} (${{ github.event.inputs.action }})"
            echo "pr_number=${{ github.event.inputs.pr_number }}" >> $GITHUB_OUTPUT
            echo "compose_name=pr-${{ github.event.inputs.pr_number }}" >> $GITHUB_OUTPUT
            echo "action=${{ github.event.inputs.action }}" >> $GITHUB_OUTPUT
          else
            echo "PR info: ${{ github.event.pull_request.number }} (${{ github.event.action }})"
            echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
            echo "compose_name=pr-${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
            
            if [ "${{ github.event.action }}" == "closed" ]; then
              echo "action=cleanup" >> $GITHUB_OUTPUT
            else
              echo "action=deploy" >> $GITHUB_OUTPUT
            fi
          fi

  deploy:
    name: Deploy Test Environment
    if: needs.setup.outputs.action == 'deploy'
    needs: setup
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      packages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Backend
        uses: docker/build-push-action@v5
        with:
          context: ./apps/backend
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-backend:pr-${{ needs.setup.outputs.pr_number }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push Frontend
        uses: docker/build-push-action@v5
        with:
          context: ./apps/frontend
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-frontend:pr-${{ needs.setup.outputs.pr_number }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NEXT_PUBLIC_API_URL=https://report-pr-${{ needs.setup.outputs.pr_number }}.${{ needs.setup.outputs.internal_domain }}/api
            NEXT_PUBLIC_APP_URL=https://report-pr-${{ needs.setup.outputs.pr_number }}.${{ needs.setup.outputs.internal_domain }}

      - name: Check if compose exists
        id: check
        run: |
          # Try to find existing compose
          response=$(curl -sf -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            "${{ env.DOKPLOY_API_URL }}/environment.one?environmentId=${{ env.TEST_ENV_ID }}" || echo '{"compose":[]}')
          
          compose_id=$(echo "$response" | jq -r --arg name "${{ needs.setup.outputs.compose_name }}" '.compose[] | select(.name == $name) | .composeId' | head -1)
          
          if [ -n "$compose_id" ] && [ "$compose_id" != "null" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "compose_id=$compose_id" >> $GITHUB_OUTPUT
            echo "Found existing compose: $compose_id"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Compose does not exist"
          fi

      - name: Create compose
        if: steps.check.outputs.exists != 'true'
        id: create
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
          BRANCH_NAME: ${{ github.head_ref }}
        run: |
          # Create new compose
          response=$(curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.create" \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            -d "{
              \"name\": \"${{ needs.setup.outputs.compose_name }}\",
              \"description\": \"PR #${{ needs.setup.outputs.pr_number }}: $PR_TITLE\",
              \"environmentId\": \"${{ env.TEST_ENV_ID }}\" 
            }")
          
          compose_id=$(echo "$response" | jq -r '.composeId')
          echo "compose_id=$compose_id" >> $GITHUB_OUTPUT
          echo "Created compose: $compose_id"
          
          # Configure GitHub source
          curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.update" \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            -d '{
              "composeId": "'"$compose_id"'",
              "sourceType": "github",
              "repository": "finance_report",
              "owner": "wangzitian0",
              "branch": "'"$BRANCH_NAME"'",
              "composePath": "docker-compose.yml",
              "githubId": "${{ env.GITHUB_INTEGRATION_ID }}"
            }'

      - name: Get compose ID
        id: compose
        run: |
          if [ -n "${{ steps.check.outputs.compose_id }}" ]; then
            echo "id=${{ steps.check.outputs.compose_id }}" >> $GITHUB_OUTPUT
          else
            echo "id=${{ steps.create.outputs.compose_id }}" >> $GITHUB_OUTPUT
          fi

      - name: Configure environment variables
        run: |
          COMPOSE_ID="${{ steps.compose.outputs.id }}"
          PR_NUMBER="${{ needs.setup.outputs.pr_number }}"
          DOMAIN="${{ needs.setup.outputs.internal_domain }}"
          
          # Construct environment variables in a temporary file to avoid indentation issues
          echo "REGISTRY=${{ env.REGISTRY }}" > .env.dokploy
          echo "IMAGE_PREFIX=${{ env.IMAGE_PREFIX }}" >> .env.dokploy
          echo "IMAGE_TAG=pr-$PR_NUMBER" >> .env.dokploy
          echo "ENV_SUFFIX=-pr-$PR_NUMBER" >> .env.dokploy
          echo "ENV_DOMAIN_SUFFIX=-pr-$PR_NUMBER" >> .env.dokploy
          echo "INTERNAL_DOMAIN=$DOMAIN" >> .env.dokploy
          echo "TRAEFIK_ENABLE=true" >> .env.dokploy
          echo "NEXT_PUBLIC_API_URL=https://report-pr-$PR_NUMBER.$DOMAIN/api" >> .env.dokploy
          echo "NEXT_PUBLIC_APP_URL=https://report-pr-$PR_NUMBER.$DOMAIN" >> .env.dokploy
          echo "DEBUG=true" >> .env.dokploy
          echo "POSTGRES_PORT=0" >> .env.dokploy
          echo "REDIS_PORT=0" >> .env.dokploy
          echo "MINIO_API_PORT=0" >> .env.dokploy
          echo "MINIO_CONSOLE_PORT=0" >> .env.dokploy
          echo "OPENROUTER_API_KEY=${{ secrets.OPENROUTER_API_KEY }}" >> .env.dokploy
          
          ENV_CONTENT=$(cat .env.dokploy)
          
          # Send to Dokploy
          # Use --arg properly without extra escaping that breaks shell/jq boundary
          PAYLOAD=$(jq -n --arg id "$COMPOSE_ID" --arg env "$ENV_CONTENT" '{composeId: $id, env: $env}')
          
          curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.update" \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            -d "$PAYLOAD"
          
          echo "Environment variables configured"

      - name: Deploy compose
        run: |
          COMPOSE_ID="${{ steps.compose.outputs.id }}"
          echo "Deploying compose: $COMPOSE_ID"
          
          # Stop if running
          curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.stop" \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            -d "{\"composeId\": \"$COMPOSE_ID\"}" 2>/dev/null || true
          
          sleep 10
          
          # Deploy
          curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.deploy" \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            -d "{\"composeId\": \"$COMPOSE_ID\"}"
          
          echo "Deployment triggered. Waiting 120s for containers..."
          sleep 120

      - name: Validate Compose Status
        env:
          DOKPLOY_API_KEY: ${{ secrets.DOKPLOY_API_KEY }}
        run: |
          COMPOSE_ID="${{ steps.compose.outputs.id }}"
          echo "Checking compose status for $COMPOSE_ID..."
          
          status=$(curl -sf -H "x-api-key: $DOKPLOY_API_KEY" \
            "${{ env.DOKPLOY_API_URL }}/compose.one?composeId=$COMPOSE_ID" \
            | jq -r '.composeStatus // "unknown"')
          
          echo "Compose status: $status"
          
          if [ "$status" = "error" ]; then
            echo "::error::Compose deployment failed with status: $status"
            # NEW: Log details
            echo "Fetching deployment details..."
            curl -sf -H "x-api-key: $DOKPLOY_API_KEY" \
              "${{ env.DOKPLOY_API_URL }}/compose.one?composeId=$COMPOSE_ID" \
              | jq -r '.deployments[]? | "Date: \(.createdAt) Status: \(.status) Error: \(.errorMessage) Log: \(.logPath)"' || echo "Failed to fetch deployment details"
            exit 1
          elif [ "$status" = "done" ] || [ "$status" = "running" ]; then
            echo "âœ… Compose status is healthy: $status"
          else
            echo "::warning::Unexpected compose status: $status"
          fi

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Test Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install httpx pytest pytest-asyncio pytest-playwright
          npx playwright install chromium --with-deps

      - name: End-to-End Tests
        id: e2e_tests
        env:
          APP_URL: https://report-pr-${{ needs.setup.outputs.pr_number }}.${{ needs.setup.outputs.internal_domain }}
          TEST_ENV: staging
          SKIP_UI_TESTS: false
        run: |
          echo "ðŸš€ Starting E2E Pipeline for $APP_URL"
          
          echo "--- Phase 1: Smoke Check (Shell) ---"
          bash scripts/smoke_test.sh "$APP_URL" staging
          
          echo "--- Phase 2: Core Flow Validation (Python) ---"
          pytest tests/e2e -v -m "smoke or e2e"
          
          echo "âœ… E2E Pipeline passed!"

      - name: Comment on PR
        uses: actions/github-script@v7
        env:
          HEAD_REF: ${{ github.head_ref }}
        with:
          script: |
            const url = `https://report-pr-${{ needs.setup.outputs.pr_number }}.${{ needs.setup.outputs.internal_domain }}`;
            const body = `## ðŸ§ª Test Environment Deployed
            
            | Service | URL |
            |---------|-----|
            | Frontend | [${url}](${url}) |
            | API Health | [${url}/api/health](${url}/api/health) |
            
            **Details:**
            - Compose: \`${{ needs.setup.outputs.compose_name }}\`
            - Branch: \`${process.env.HEAD_REF}\`
            - Commit: \`${{ github.sha }}\`
            
            > â³ First deployment may take 3-5 minutes for build + SSL certificate.
            
            _This environment will be automatically cleaned up when the PR is closed._`;
            
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(c => 
              c.user.type === 'Bot' && c.body.includes('ðŸ§ª Test Environment Deployed')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }

  cleanup:
    name: Cleanup Test Environment
    if: needs.setup.outputs.action == 'cleanup'
    needs: setup
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Find and remove compose
        run: |
          echo "Looking for compose: ${{ needs.setup.outputs.compose_name }}"
          
          # Get environment to find compose
          response=$(curl -sf -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            "${{ env.DOKPLOY_API_URL }}/environment.one?environmentId=${{ env.TEST_ENV_ID }}" || echo '{"compose":[]}')
          
          compose_id=$(echo "$response" | jq -r --arg name "${{ needs.setup.outputs.compose_name }}" '.compose[] | select(.name == $name) | .composeId' | head -1)
          
          if [ -n "$compose_id" ] && [ "$compose_id" != "null" ]; then
            echo "Found compose: $compose_id"
            
            # Stop compose
            curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.stop" \
              -H "Content-Type: application/json" \
              -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
              -d "{\"composeId\": \"$compose_id\"}" 2>/dev/null || true
            
            sleep 15
            
            # Clean postgres volume (prevents password issues in future PRs)
            # Dokploy API doesn't expose volume management, so we use Dokploy's compose delete
            # which should clean up associated resources
            echo "Volume cleanup will be handled by compose deletion"
            
            # Delete compose
            curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.delete" \
              -H "Content-Type: application/json" \
              -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
              -d "{\"composeId\": \"$compose_id\"}"
            
            echo "Compose deleted"
          else
            echo "Compose not found, nothing to cleanup"
          fi

      - name: Comment cleanup notice
        uses: actions/github-script@v7
        with:
          script: |
            const body = `## ðŸ§¹ Test Environment Cleaned Up
            
            The test environment for this PR has been removed.
            
            - Compose: \`${{ needs.setup.outputs.compose_name }}\` âœ“ deleted`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body,
            });