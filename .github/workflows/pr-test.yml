# PR Test Environment Workflow
#
# Triggers:
#   - PR opened/synchronized: Build â†’ Create compose â†’ Deploy
#   - PR closed: Stop â†’ Delete compose
#
# Each PR gets an isolated environment with its own DB/Redis/MinIO.
# Uses docker-compose.yml from this repo (not infra2).

name: PR Test Environment

on:
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches: [main]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR Number'
        required: true
      action:
        description: 'Action'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - cleanup

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}/finance_report
  DOKPLOY_API_URL: https://cloud.zitian.party/api
  TEST_ENV_ID: -fzh5EGJN74I1AjNEpVUr
  GITHUB_INTEGRATION_ID: 126refcRlCoWj6pmPXElU
  INTERNAL_DOMAIN: zitian.party

jobs:
  setup:
    name: Setup Variables
    runs-on: ubuntu-latest
    outputs:
      compose_name: ${{ steps.info.outputs.compose_name }}
      pr_number: ${{ steps.info.outputs.pr_number }}
      action: ${{ steps.info.outputs.action }}
    steps:
      - name: Determine Params
        id: info
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "Manual trigger for PR ${{ github.event.inputs.pr_number }} (${{ github.event.inputs.action }})"
            echo "pr_number=${{ github.event.inputs.pr_number }}" >> $GITHUB_OUTPUT
            echo "compose_name=pr-${{ github.event.inputs.pr_number }}" >> $GITHUB_OUTPUT
            echo "action=${{ github.event.inputs.action }}" >> $GITHUB_OUTPUT
          else
            echo "PR info: ${{ github.event.pull_request.number }} (${{ github.event.action }})"
            echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
            echo "compose_name=pr-${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
            
            if [ "${{ github.event.action }}" == "closed" ]; then
              echo "action=cleanup" >> $GITHUB_OUTPUT
            else
              echo "action=deploy" >> $GITHUB_OUTPUT
            fi
          fi

  deploy:
    name: Deploy Test Environment
    if: needs.setup.outputs.action == 'deploy'
    needs: setup
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    environment:
      name: pr-${{ github.event.pull_request.number }}
      url: https://report-pr-${{ needs.setup.outputs.pr_number }}.${{ env.INTERNAL_DOMAIN }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check if compose exists
        id: check
        run: |
          # Try to find existing compose
          response=$(curl -sf -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            "${{ env.DOKPLOY_API_URL }}/environment.one?environmentId=${{ env.TEST_ENV_ID }}" || echo '{"compose":[]}')
          
          compose_id=$(echo "$response" | jq -r --arg name "${{ needs.setup.outputs.compose_name }}" '.compose[] | select(.name == $name) | .composeId' | head -1)
          
          if [ -n "$compose_id" ] && [ "$compose_id" != "null" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "compose_id=$compose_id" >> $GITHUB_OUTPUT
            echo "Found existing compose: $compose_id"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Compose does not exist"
          fi

      - name: Create compose
        if: steps.check.outputs.exists != 'true'
        id: create
        run: |
          # Create new compose
          response=$(curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.create" \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            -d '{
              "name": "${{ needs.setup.outputs.compose_name }}",
              "description": "PR #${{ needs.setup.outputs.pr_number }}: ${{ github.event.pull_request.title }}",
              "environmentId": "${{ env.TEST_ENV_ID }}"
            }')
          
          compose_id=$(echo "$response" | jq -r '.composeId')
          echo "compose_id=$compose_id" >> $GITHUB_OUTPUT
          echo "Created compose: $compose_id"
          
          # Configure GitHub source
          curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.update" \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            -d '{
              "composeId": "'"$compose_id"'",
              "sourceType": "github",
              "repository": "finance_report",
              "owner": "wangzitian0",
              "branch": "${{ github.head_ref }}",
              "composePath": "docker-compose.yml",
              "githubId": "${{ env.GITHUB_INTEGRATION_ID }}"
            }'

      - name: Get compose ID
        id: compose
        run: |
          if [ -n "${{ steps.check.outputs.compose_id }}" ]; then
            echo "id=${{ steps.check.outputs.compose_id }}" >> $GITHUB_OUTPUT
          else
            echo "id=${{ steps.create.outputs.compose_id }}" >> $GITHUB_OUTPUT
          fi

      - name: Configure environment variables
        run: |
          COMPOSE_ID="${{ steps.compose.outputs.id }}"
          
          # Set environment variables for Dokploy
          env_vars="ENV_SUFFIX=-pr-${{ needs.setup.outputs.pr_number }}
          ENV_DOMAIN_SUFFIX=-pr-${{ needs.setup.outputs.pr_number }}
          INTERNAL_DOMAIN=${{ env.INTERNAL_DOMAIN }}
          TRAEFIK_ENABLE=true
          NEXT_PUBLIC_API_URL=https://report-pr-${{ needs.setup.outputs.pr_number }}.${{ env.INTERNAL_DOMAIN }}/api
          NEXT_PUBLIC_APP_URL=https://report-pr-${{ needs.setup.outputs.pr_number }}.${{ env.INTERNAL_DOMAIN }}
          DEBUG=true
          POSTGRES_PORT=0
          REDIS_PORT=0
          MINIO_API_PORT=0
          MINIO_CONSOLE_PORT=0
          OPENROUTER_API_KEY=${{ secrets.OPENROUTER_API_KEY }}"
          
          curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.update" \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            -d "$(jq -n --arg id "$COMPOSE_ID" --arg env "$env_vars" '{composeId: $id, env: $env}')"
          
          echo "Environment variables configured"

      - name: Deploy compose
        run: |
          COMPOSE_ID="${{ steps.compose.outputs.id }}"
          echo "Deploying compose: $COMPOSE_ID"
          
          # Stop if running
          curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.stop" \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            -d "{\"composeId\": \"$COMPOSE_ID\"}" 2>/dev/null || true
          
          sleep 10
          
          # Deploy
          curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.deploy" \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            -d "{\"composeId\": \"$COMPOSE_ID\"}"
          
          echo "Deployment triggered. Waiting 90s for containers..."
          sleep 90

      - name: Validate Compose Status
        env:
          DOKPLOY_API_KEY: ${{ secrets.DOKPLOY_API_KEY }}
        run: |
          COMPOSE_ID="${{ steps.compose.outputs.id }}"
          echo "Checking compose status for $COMPOSE_ID..."
          
          status=$(curl -sf -H "x-api-key: $DOKPLOY_API_KEY" \
            "${{ env.DOKPLOY_API_URL }}/compose.one?composeId=$COMPOSE_ID" \
            | jq -r '.composeStatus // "unknown"')
          
          echo "Compose status: $status"
          
          if [ "$status" = "error" ]; then
            echo "::error::Compose deployment failed with status: $status"
            # NEW: Log details
            echo "Fetching deployment details..."
            curl -sf -H "x-api-key: $DOKPLOY_API_KEY" \
              "${{ env.DOKPLOY_API_URL }}/compose.one?composeId=$COMPOSE_ID" \
              | jq -r '.deployments[]? | "Date: \(.createdAt) Status: \(.status) Error: \(.errorMessage) Log: \(.logPath)"' || echo "Failed to fetch deployment details"
            exit 1
          elif [ "$status" = "done" ] || [ "$status" = "running" ]; then
            echo "âœ… Compose status is healthy: $status"
          else
            echo "::warning::Unexpected compose status: $status"
          fi

      - name: Health Check
        id: health_check
        run: |
          BASE_URL="https://report-pr-${{ needs.setup.outputs.pr_number }}.${{ env.INTERNAL_DOMAIN }}"
          echo "Running health check on $BASE_URL..."
          
          for i in {1..10}; do
            if curl -sf "$BASE_URL/api/health" > /dev/null; then
              echo "âœ… Health check passed!"
              echo "healthy=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "Attempt $i/10 failed, waiting 10s..."
            sleep 10
          done
          
          echo "::error::Health check failed after 10 attempts"
          echo "healthy=false" >> $GITHUB_OUTPUT
          exit 1

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const url = `https://report-pr-${{ needs.setup.outputs.pr_number }}.${{ env.INTERNAL_DOMAIN }}`;
            const body = `## ðŸ§ª Test Environment Deployed
            
            | Service | URL |
            |---------|-----|
            | Frontend | [${url}](${url}) |
            | API Health | [${url}/api/health](${url}/api/health) |
            
            **Details:**
            - Compose: \`${{ needs.setup.outputs.compose_name }}\`
            - Branch: \`${{ github.head_ref }}\`
            - Commit: \`${{ github.sha }}\`
            
            > â³ First deployment may take 3-5 minutes for build + SSL certificate.
            
            _This environment will be automatically cleaned up when the PR is closed._`;
            
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(c => 
              c.user.type === 'Bot' && c.body.includes('ðŸ§ª Test Environment Deployed')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }

  cleanup:
    name: Cleanup Test Environment
    if: needs.setup.outputs.action == 'cleanup'
    needs: setup
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Find and remove compose
        run: |
          echo "Looking for compose: ${{ needs.setup.outputs.compose_name }}"
          
          # Get environment to find compose
          response=$(curl -sf -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            "${{ env.DOKPLOY_API_URL }}/environment.one?environmentId=${{ env.TEST_ENV_ID }}" || echo '{"compose":[]}')
          
          compose_id=$(echo "$response" | jq -r --arg name "${{ needs.setup.outputs.compose_name }}" '.compose[] | select(.name == $name) | .composeId' | head -1)
          
          if [ -n "$compose_id" ] && [ "$compose_id" != "null" ]; then
            echo "Found compose: $compose_id"
            
            # Stop compose
            curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.stop" \
              -H "Content-Type: application/json" \
              -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
              -d "{\"composeId\": \"$compose_id\"}" 2>/dev/null || true
            
            sleep 15
            
            # Clean postgres volume (prevents password issues in future PRs)
            # Dokploy API doesn't expose volume management, so we use Dokploy's compose delete
            # which should clean up associated resources
            echo "Volume cleanup will be handled by compose deletion"
            
            # Delete compose
            curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.delete" \
              -H "Content-Type: application/json" \
              -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
              -d "{\"composeId\": \"$compose_id\"}"
            
            echo "Compose deleted"
          else
            echo "Compose not found, nothing to cleanup"
          fi

      - name: Comment cleanup notice
        uses: actions/github-script@v7
        with:
          script: |
            const body = `## ðŸ§¹ Test Environment Cleaned Up
            
            The test environment for this PR has been removed.
            
            - Compose: \`${{ needs.setup.outputs.compose_name }}\` âœ“ deleted`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body,
            });
