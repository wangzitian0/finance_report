# PR Test Environment Workflow - Triggered by PR events
#
# Each PR gets an isolated environment with its own DB/Redis/MinIO.
# Uses docker-compose.yml from this repo (not infra2).

name: PR Test Environment

on:
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches: [main]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR Number'
        required: true
      action:
        description: 'Action'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - cleanup

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}/finance_report
  DOKPLOY_API_URL: https://cloud.zitian.party/api
  TEST_ENV_ID: -fzh5EGJN74I1AjNEpVUr
  GITHUB_INTEGRATION_ID: 126refcRlCoWj6pmPXElU
  INTERNAL_DOMAIN: zitian.party

jobs:
  setup:
    name: Setup Variables
    runs-on: ubuntu-latest
    outputs:
      compose_name: ${{ steps.info.outputs.compose_name }}
      pr_number: ${{ steps.info.outputs.pr_number }}
      action: ${{ steps.info.outputs.action }}
      internal_domain: ${{ steps.info.outputs.internal_domain }}
    steps:
      - name: Determine Params
        id: info
        run: |
          {
            echo "internal_domain=${{ env.INTERNAL_DOMAIN }}"
            if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
              echo "Manual trigger for PR ${{ github.event.inputs.pr_number }} (${{ github.event.inputs.action }})" >&2
              echo "pr_number=${{ github.event.inputs.pr_number }}"
              echo "compose_name=pr-${{ github.event.inputs.pr_number }}"
              echo "action=${{ github.event.inputs.action }}"
            else
              echo "PR info: ${{ github.event.pull_request.number }} (${{ github.event.action }})" >&2
              echo "pr_number=${{ github.event.pull_request.number }}"
              echo "compose_name=pr-${{ github.event.pull_request.number }}"
              
              if [ "${{ github.event.action }}" == "closed" ]; then
                echo "action=cleanup"
              else
                echo "action=deploy"
              fi
            fi
          } >> "$GITHUB_OUTPUT"

  # Build images in parallel using matrix strategy
  build:
    name: Build ${{ matrix.app }} Image
    if: needs.setup.outputs.action == 'deploy'
    needs: setup
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        app: [backend, frontend]
        include:
          - app: backend
            context: ./apps/backend
            build_args: ""
          - app: frontend
            context: ./apps/frontend
            # build_args set dynamically in step
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Log in to Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push ${{ matrix.app }}
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.context }}
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-${{ matrix.app }}:pr-${{ needs.setup.outputs.pr_number }}
          cache-from: |
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-${{ matrix.app }}:staging
            type=gha
          cache-to: type=gha,mode=max
          build-args: |
            GIT_COMMIT_SHA=${{ github.sha }}
            ${{ matrix.app == 'frontend' && format('NEXT_PUBLIC_API_URL=https://report-pr-{0}.{1}', needs.setup.outputs.pr_number, needs.setup.outputs.internal_domain) || '' }}
            ${{ matrix.app == 'frontend' && format('NEXT_PUBLIC_APP_URL=https://report-pr-{0}.{1}', needs.setup.outputs.pr_number, needs.setup.outputs.internal_domain) || '' }}

  deploy:
    name: Deploy Test Environment
    if: needs.setup.outputs.action == 'deploy'
    needs: [setup, build]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Check Deployment Dependencies
        env:
          DOKPLOY_API_KEY: ${{ secrets.DOKPLOY_API_KEY }}
          DOKPLOY_API_URL: ${{ env.DOKPLOY_API_URL }}
        run: bash scripts/check_deployment_deps.sh

      - name: Check if compose exists
        id: check
        run: |
          # Try to find existing compose
          response=$(curl -sf -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            "${{ env.DOKPLOY_API_URL }}/environment.one?environmentId=${{ env.TEST_ENV_ID }}" 2>&1)
          curl_exit=$?
          
          if [ $curl_exit -ne 0 ]; then
            echo "::warning::Failed to fetch environment (curl exit $curl_exit). Assuming compose doesn't exist."
            echo "Response: $response"
            response='{"compose":[]}'
          fi
          
          compose_id=$(echo "$response" | jq -r --arg name "${{ needs.setup.outputs.compose_name }}" '.compose[] | select(.name == $name) | .composeId' | head -1)
          
          if [ -n "$compose_id" ] && [ "$compose_id" != "null" ]; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
            echo "compose_id=$compose_id" >> "$GITHUB_OUTPUT"
            echo "Found existing compose: $compose_id"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
            echo "Compose does not exist"
          fi

      - name: Create compose
        if: steps.check.outputs.exists != 'true'
        id: create
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
          BRANCH_NAME: ${{ github.head_ref }}
        run: |
          # Create new compose
          response=$(curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.create" \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            -d "{
              \"name\": \"${{ needs.setup.outputs.compose_name }}\",
              \"description\": \"PR #${{ needs.setup.outputs.pr_number }}: $PR_TITLE\",
              \"environmentId\": \"${{ env.TEST_ENV_ID }}\" 
            }")
          
          compose_id=$(echo "$response" | jq -r '.composeId')
          echo "compose_id=$compose_id" >> "$GITHUB_OUTPUT"
          echo "Created compose: $compose_id"
          
          # Configure GitHub source using jq for proper JSON escaping
          PAYLOAD=$(jq -n \
            --arg id "$compose_id" \
            --arg branch "$BRANCH_NAME" \
            '{
              composeId: $id,
              sourceType: "github",
              repository: "finance_report",
              owner: "wangzitian0",
              branch: $branch,
              composePath: "docker-compose.yml",
              githubId: "${{ env.GITHUB_INTEGRATION_ID }}"
            }')
          
          curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.update" \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            -d "$PAYLOAD"

      - name: Get compose ID
        id: compose
        run: |
          if [ -n "${{ steps.check.outputs.compose_id }}" ]; then
            echo "id=${{ steps.check.outputs.compose_id }}" >> "$GITHUB_OUTPUT"
          else
            echo "id=${{ steps.create.outputs.compose_id }}" >> "$GITHUB_OUTPUT"
          fi

      - name: Configure environment variables
        run: |
          COMPOSE_ID="${{ steps.compose.outputs.id }}"
          PR_NUMBER="${{ needs.setup.outputs.pr_number }}"
          DOMAIN="${{ needs.setup.outputs.internal_domain }}"
          
          # Calculate unique ports based on PR number to avoid conflicts
          # Range: 30000-34000 (Supports PRs up to ~9999)
          DB_PORT=$((30000 + PR_NUMBER))
          REDIS_PORT=$((31000 + PR_NUMBER))
          MINIO_API_PORT=$((32000 + PR_NUMBER))
          MINIO_CONSOLE_PORT=$((33000 + PR_NUMBER))
          
          # Construct environment variables in a temporary file to avoid indentation issues
          {
            echo "GIT_COMMIT_SHA=${{ github.sha }}"
            echo "REGISTRY=${{ env.REGISTRY }}"
            echo "IMAGE_PREFIX=${{ env.IMAGE_PREFIX }}"
            echo "IMAGE_TAG=pr-$PR_NUMBER"
            echo "ENV_SUFFIX=-pr-$PR_NUMBER"
            echo "ENV_DOMAIN_SUFFIX=-pr-$PR_NUMBER"
            echo "INTERNAL_DOMAIN=$DOMAIN"
            echo "TRAEFIK_ENABLE=true"
            echo "NEXT_PUBLIC_API_URL=https://report-pr-$PR_NUMBER.$DOMAIN"
            echo "NEXT_PUBLIC_APP_URL=https://report-pr-$PR_NUMBER.$DOMAIN"
            echo "DEBUG=true"
            
            # Host binding: 127.0.0.1 to avoid exposing to public internet
            echo "DB_PORTS=127.0.0.1:$DB_PORT:5432"
            echo "REDIS_PORTS=127.0.0.1:$REDIS_PORT:6379"
            echo "MINIO_API_PORTS=127.0.0.1:$MINIO_API_PORT:9000"
            echo "MINIO_CONSOLE_PORTS=127.0.0.1:$MINIO_CONSOLE_PORT:9001"
            
            echo "OPENROUTER_API_KEY=${{ secrets.OPENROUTER_API_KEY }}"
            echo "COMPOSE_PROFILES=infra,app"
            
            # CRITICAL: Use unique hostnames in Dokploy shared network
            # Container names with ENV_SUFFIX are used as hostnames
            echo "DB_HOST=finance-report-db-pr-$PR_NUMBER"
            echo "REDIS_HOST=finance-report-redis-pr-$PR_NUMBER"
            echo "S3_HOST=finance-report-minio-pr-$PR_NUMBER"
            
            # SigNoz Logging (EPIC-010)
            echo "OTEL_EXPORTER_OTLP_ENDPOINT=http://platform-signoz-otel-collector:4318"
            echo "OTEL_SERVICE_NAME=finance-report-backend"
            echo "OTEL_RESOURCE_ATTRIBUTES=deployment.environment=pr-$PR_NUMBER"
          } > .env.dokploy
          
          ENV_CONTENT=$(cat .env.dokploy)
          
          # Send to Dokploy
          # Use --arg properly without extra escaping that breaks shell/jq boundary
          PAYLOAD=$(jq -n --arg id "$COMPOSE_ID" --arg env "$ENV_CONTENT" '{composeId: $id, env: $env}')
          
          curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.update" \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            -d "$PAYLOAD"
          
          echo "Environment variables configured"

      - name: Deploy compose
        id: deploy
        env:
          DOKPLOY_API_KEY: ${{ secrets.DOKPLOY_API_KEY }}
        run: |
          COMPOSE_ID="${{ steps.compose.outputs.id }}"
          echo "compose_id=$COMPOSE_ID" >> "$GITHUB_OUTPUT"
          echo "Deploying compose: $COMPOSE_ID"
          
          # Stop existing compose (best-effort, log but don't fail)
          echo "Stopping existing compose..."
          STOP_RESPONSE=$(curl -sS -w "\n%{http_code}" -X POST "${{ env.DOKPLOY_API_URL }}/compose.stop" \
            -H "Content-Type: application/json" \
            -H "x-api-key: $DOKPLOY_API_KEY" \
            -d "{\"composeId\": \"$COMPOSE_ID\"}" 2>&1) || true
          
          STOP_HTTP=$(echo "$STOP_RESPONSE" | tail -1)
          if [[ "$STOP_HTTP" != "200" && "$STOP_HTTP" != "000" ]]; then
            echo "::warning::compose.stop returned HTTP $STOP_HTTP (may be expected if already stopped)"
          fi
          
          sleep 5
          
          curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.deploy" \
            -H "Content-Type: application/json" \
            -H "x-api-key: $DOKPLOY_API_KEY" \
            -d "{\"composeId\": \"$COMPOSE_ID\"}"
          
          echo "Deployment triggered, waiting 10s for status to update..."
          sleep 10

      - name: Poll Deployment Status
        env:
          DOKPLOY_API_KEY: ${{ secrets.DOKPLOY_API_KEY }}
        run: |
          COMPOSE_ID="${{ steps.compose.outputs.id }}"
          echo "Polling deployment status for $COMPOSE_ID..."
          
          # Track the start time to detect stale error status
          START_TIME=$(date +%s)
          LAST_STATUS=""
          LAST_DEPLOY_STATUS=""
          
          for i in $(seq 1 60); do
            response=$(curl -sf -H "x-api-key: $DOKPLOY_API_KEY" \
              "${{ env.DOKPLOY_API_URL }}/compose.one?composeId=$COMPOSE_ID" 2>&1)
            curl_exit=$?
            
            if [ $curl_exit -ne 0 ]; then
              echo "::warning::Attempt $i/60: API request failed (curl exit $curl_exit)"
              sleep 5
              continue
            fi
            
            status=$(echo "$response" | jq -r '.composeStatus // "unknown"')
            LAST_STATUS="$status"
            
            # Get the latest deployment status and time
            latest_deploy=$(echo "$response" | jq -r '.deployments[-1] // {}')
            latest_status=$(echo "$latest_deploy" | jq -r '.status // "unknown"')
            latest_started=$(echo "$latest_deploy" | jq -r '.startedAt // ""')
            LAST_DEPLOY_STATUS="$latest_status"
            
            echo "Attempt $i/60: composeStatus=$status, latestDeployment=$latest_status"
            
            # Check if latest deployment started after we triggered (within last 2 min)
            if [ -n "$latest_started" ] && [ "$latest_started" != "null" ]; then
              # Try multiple date formats for ISO 8601 parsing
              deploy_time=$(date -d "$latest_started" +%s 2>/dev/null || \
                           date -d "${latest_started%.*}Z" +%s 2>/dev/null || \
                           echo "")
              
              if [ -z "$deploy_time" ]; then
                echo "::warning::Could not parse timestamp: $latest_started (using fallback)"
              else
                time_diff=$((START_TIME - deploy_time))
                
                # If latest deployment is recent (within 120s of our start)
                if [ "$time_diff" -lt 120 ] && [ "$time_diff" -gt -300 ]; then
                  if [ "$latest_status" = "done" ]; then
                    echo "âœ… Latest deployment completed successfully"
                    exit 0
                  elif [ "$latest_status" = "error" ]; then
                    echo "::error::Latest deployment failed"
                    echo "$latest_deploy" | jq -r '"Error: \(.errorMessage // "unknown")"' || true
                    exit 1
                  fi
                fi
              fi
            fi
            
            # Fallback: check compose-level status after a grace period
            if [ "$i" -gt 5 ]; then
              if [ "$status" = "done" ] || [ "$status" = "running" ]; then
                echo "âœ… Deployment completed with status: $status"
                exit 0
              fi
            fi
            
            sleep 5
          done
          
          # Timeout - provide diagnostics
          echo "::error::Deployment did not complete within 5 minutes"
          echo "=== FINAL STATE DIAGNOSTICS ==="
          echo "Last composeStatus: $LAST_STATUS"
          echo "Last deployment status: $LAST_DEPLOY_STATUS"
          echo "Start time: $(date -d "@$START_TIME" 2>/dev/null || echo "$START_TIME")"
          echo "API response (last 1000 chars):"
          echo "$response" | tail -c 1000
          echo "================================"
          exit 1

      - name: Wait for API readiness
        env:
          APP_URL: https://report-pr-${{ needs.setup.outputs.pr_number }}.${{ needs.setup.outputs.internal_domain }}
        run: |
          python3 - << 'EOF'
          import urllib.request
          import ssl
          import time
          import os
          import sys

          url = os.environ["APP_URL"] + "/api/health"
          print(f"Waiting for API readiness at {url}")
          
          ctx = ssl.create_default_context()
          ctx.check_hostname = False
          ctx.verify_mode = ssl.CERT_NONE
          
          max_attempts = 30
          for attempt in range(1, max_attempts + 1):
              delay = min(5 + (attempt // 5) * 5, 30)
              try:
                  with urllib.request.urlopen(url, timeout=15, context=ctx) as response:
                      if 200 <= response.getcode() < 400:
                          print(f"âœ… API ready (status {response.getcode()})")
                          sys.exit(0)
                      print(f"âš ï¸ Attempt {attempt}/{max_attempts}: status {response.getcode()}")
              except Exception as e:
                  print(f"âŒ Attempt {attempt}/{max_attempts}: {type(e).__name__}: {e}")
              
              print(f"   Retrying in {delay}s...")
              time.sleep(delay)
          
          print("::error::API not ready after all attempts")
          sys.exit(1)
          EOF

      - name: Setup E2E Tests
        uses: ./.github/actions/setup-e2e-tests

      - name: End-to-End Tests
        id: e2e_tests
        env:
          APP_URL: https://report-pr-${{ needs.setup.outputs.pr_number }}.${{ needs.setup.outputs.internal_domain }}
          TEST_ENV: staging
          SKIP_UI_TESTS: false
          EXPECTED_SHA: ${{ github.sha }}
        run: |
          echo "ðŸš€ Starting E2E Pipeline for $APP_URL"
          
          echo "--- Phase 1: Smoke Check (Shell) ---"
          bash scripts/smoke_test.sh "$APP_URL" staging
          
          echo "--- Phase 2: Core Flow Validation (Python) ---"
          pytest tests/e2e -v -m "smoke or e2e" --junit-xml=test-results.xml
          
          echo "--- Phase 3: Critical Tests Check ---"
          python scripts/check_critical_tests.py test-results.xml
          
          echo "âœ… E2E Pipeline passed!"

      - name: Rollback on E2E Failure
        if: failure() && steps.e2e_tests.outcome == 'failure'
        env:
          DOKPLOY_API_KEY: ${{ secrets.DOKPLOY_API_KEY }}
        run: |
          COMPOSE_ID="${{ steps.deploy.outputs.compose_id }}"
          echo "::warning::E2E tests failed. Stopping compose to prevent broken deployment..."
          
          # Best-effort stop, log result but don't fail the job
          STOP_RESPONSE=$(curl -sS -w "\n%{http_code}" -X POST "${{ env.DOKPLOY_API_URL }}/compose.stop" \
            -H "Content-Type: application/json" \
            -H "x-api-key: $DOKPLOY_API_KEY" \
            -d "{\"composeId\": \"$COMPOSE_ID\"}" 2>&1) || true
          
          STOP_HTTP=$(echo "$STOP_RESPONSE" | tail -1)
          if [[ "$STOP_HTTP" == "200" ]]; then
            echo "âœ… Compose stopped successfully"
          else
            echo "::warning::compose.stop returned HTTP $STOP_HTTP"
            echo "Response: $(echo "$STOP_RESPONSE" | head -n -1)"
          fi
          
          echo "Check logs for E2E failure details."

      - name: Comment on PR
        uses: actions/github-script@v7
        env:
          HEAD_REF: ${{ github.head_ref }}
          PR_NUMBER: ${{ needs.setup.outputs.pr_number }}
          INTERNAL_DOMAIN: ${{ needs.setup.outputs.internal_domain }}
          COMPOSE_NAME: ${{ needs.setup.outputs.compose_name }}
        with:
          script: |
            const url = `https://report-pr-${process.env.PR_NUMBER}.${process.env.INTERNAL_DOMAIN}`;
            const body = `## ðŸ§ª Test Environment Deployed
            
            | Service | URL |
            |---------|-----|
            | Frontend | [${url}](${url}) |
            | API Health | [${url}/api/health](${url}/api/health) |
            
            **Details:**
            - Compose: \`${process.env.COMPOSE_NAME}\`
            - Branch: \`${process.env.HEAD_REF}\`
            - Commit: \`${{ github.sha }}\`
            
            > â³ First deployment may take 3-5 minutes for build + SSL certificate.
            
            _This environment will be automatically cleaned up when the PR is closed._`;
            
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(c => 
              c.user.type === 'Bot' && c.body.includes('ðŸ§ª Test Environment Deployed')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            }

  cleanup:
    name: Cleanup Test Environment
    if: needs.setup.outputs.action == 'cleanup'
    needs: setup
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Find and remove compose
        run: |
          echo "Looking for compose: ${{ needs.setup.outputs.compose_name }}"
          
          # Get environment to find compose
          response=$(curl -sf -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            "${{ env.DOKPLOY_API_URL }}/environment.one?environmentId=${{ env.TEST_ENV_ID }}" 2>&1)
          curl_exit=$?
          
          if [ $curl_exit -ne 0 ]; then
            echo "::warning::Failed to fetch environment (curl exit $curl_exit). Response: $response"
            response='{"compose":[]}'
          fi
          
          compose_id=$(echo "$response" | jq -r --arg name "${{ needs.setup.outputs.compose_name }}" '.compose[] | select(.name == $name) | .composeId' | head -1)
          
          if [ -n "$compose_id" ] && [ "$compose_id" != "null" ]; then
            echo "Found compose: $compose_id"
            
            # Stop compose (best-effort with logging)
            echo "Stopping compose..."
            STOP_RESPONSE=$(curl -sS -w "\n%{http_code}" -X POST "${{ env.DOKPLOY_API_URL }}/compose.stop" \
              -H "Content-Type: application/json" \
              -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
              -d "{\"composeId\": \"$compose_id\"}" 2>&1) || true
            
            STOP_HTTP=$(echo "$STOP_RESPONSE" | tail -1)
            if [[ "$STOP_HTTP" != "200" ]]; then
              echo "::warning::compose.stop returned HTTP $STOP_HTTP (continuing with deletion)"
            fi
            
            sleep 15
            
            # Clean postgres volume (prevents password issues in future PRs)
            # Dokploy API doesn't expose volume management, so we use Dokploy's compose delete
            # which should clean up associated resources
            echo "Volume cleanup will be handled by compose deletion"
            
            # Delete compose
            curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.delete" \
              -H "Content-Type: application/json" \
              -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
              -d "{\"composeId\": \"$compose_id\"}"
            
            echo "Compose deleted"
          else
            echo "Compose not found, nothing to cleanup"
          fi

      - name: Comment cleanup notice
        uses: actions/github-script@v7
        with:
          script: |
            const body = `## ðŸ§¹ Test Environment Cleaned Up
            
            The test environment for this PR has been removed.
            
            - Compose: \`${{ needs.setup.outputs.compose_name }}\` âœ“ deleted`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body,
            });
