# Staging Deployment Workflow
#
# Triggers: Push to main branch
# Actions: Build images → Deploy to staging → Smoke test
#
# Staging tracks the latest main branch commit.
# Data is persisted between deployments.

name: Deploy Staging

on:
  push:
    branches: [main]
    paths:
      - 'apps/backend/**'
      - 'apps/frontend/**'
      - '.github/workflows/staging-deploy.yml'

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}/finance_report
  DOKPLOY_API_URL: https://cloud.zitian.party/api
  STAGING_COMPOSE_ID: A6V-hbJlgHMwgPDoTDnhH
  DEPLOY_WAIT_SECONDS: 120

jobs:
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required to push tags
      packages: write
    outputs:
      new_version: ${{ steps.bump_version.outputs.new_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required to fetch all tags

      - name: Bump Patch Version
        id: bump_version
        run: |
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Get latest tag (format vX.Y.Z) or default to v0.0.0
          latest_tag=$(git describe --tags --abbrev=0 --match "v[0-9]*.[0-9]*.[0-9]*" 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $latest_tag"
          
          # Remove 'v' prefix
          version=${latest_tag#v}
          
          # Split into array
          IFS='.' read -r -a parts <<< "$version"
          major=${parts[0]}
          minor=${parts[1]}
          patch=${parts[2]}
          
          # Increment patch
          new_patch=$((patch + 1))
          new_version="v$major.$minor.$new_patch"
          
          echo "New version: $new_version"
          echo "new_version=$new_version" >> $GITHUB_OUTPUT
          
          # Create and push tag
          git tag -a "$new_version" -m "Release $new_version"
          git push origin "$new_version"

      - name: Log in to Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Backend
        uses: docker/build-push-action@v5
        with:
          context: ./apps/backend
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-backend:${{ steps.bump_version.outputs.new_version }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-backend:staging
            ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-backend:latest

      - name: Build and push Frontend
        uses: docker/build-push-action@v5
        with:
          context: ./apps/frontend
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-frontend:${{ steps.bump_version.outputs.new_version }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-frontend:staging
            ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-frontend:latest
          build-args: |
            NEXT_PUBLIC_API_URL=https://report-staging.zitian.party
            NEXT_PUBLIC_APP_URL=https://report-staging.zitian.party
          # NEXT_PUBLIC_API_URL: no /api suffix - frontend paths include /api/

      - name: Deploy to Staging
        env:
          IMAGE_TAG: ${{ steps.bump_version.outputs.new_version }}
        run: |
          echo "Deploying $IMAGE_TAG to staging..."
          
          # Get current env (suppress output to avoid leaking secrets)
          env_response=$(curl -sf -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            "${{ env.DOKPLOY_API_URL }}/compose.one?composeId=${{ env.STAGING_COMPOSE_ID }}" 2>/dev/null)
          
          if [ $? -ne 0 ] || [ -z "$env_response" ]; then
            echo "ERROR: Failed to fetch current environment from API"
            exit 1
          fi
          
          current_env=$(echo "$env_response" | jq -r '.env // empty')
          
          # Update Compose Path to use production file
          # Note: Currently relying on default or manually set path, or inject via update
          # For strict correctness, we assume the Stack is configured or we use the 'compose' update API properly.
          # Since we are using image-based deployment now, we rely on the IMAGE_TAG env var.
          
          # Mask any sensitive values
          while IFS= read -r line; do
            case "$line" in
              VAULT_*=*|[A-Z_]*TOKEN=*|[A-Z_]*SECRET=*|[A-Z_]*KEY=*|[A-Z_]*PASSWORD=*)
                value=${line#*=}
                if [ -n "$value" ]; then
                  echo "::add-mask::$value"
                fi
                ;;
            esac
          done <<< "$current_env"
          
          # Update IMAGE_TAG
          if echo "$current_env" | grep -q '^IMAGE_TAG='; then
            new_env=$(echo "$current_env" | sed "s/^IMAGE_TAG=.*/IMAGE_TAG=$IMAGE_TAG/")
          else
            new_env=$(printf "%s\nIMAGE_TAG=%s" "$current_env" "$IMAGE_TAG")
          fi
          
          # Add/Update NEXT_PUBLIC_APP_URL
          if echo "$new_env" | grep -q '^NEXT_PUBLIC_APP_URL='; then
            new_env=$(echo "$new_env" | sed "s|^NEXT_PUBLIC_APP_URL=.*|NEXT_PUBLIC_APP_URL=https://report-staging.zitian.party|")
          else
            new_env=$(printf "%s\nNEXT_PUBLIC_APP_URL=%s" "$new_env" "https://report-staging.zitian.party")
          fi
          
          # Update environment
          if ! curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.update" \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            -d "$(jq -n --arg id "${{ env.STAGING_COMPOSE_ID }}" --arg env "$new_env" '{composeId: $id, env: $env}')" > /dev/null; then
            echo "ERROR: Failed to update environment"
            exit 1
          fi
          
          echo "Environment updated to use image tag: $IMAGE_TAG"
          
          # Redeploy
          curl -sf -X POST "${{ env.DOKPLOY_API_URL }}/compose.deploy" \
            -H "Content-Type: application/json" \
            -H "x-api-key: ${{ secrets.DOKPLOY_API_KEY }}" \
            -d "$(jq -n --arg id "${{ env.STAGING_COMPOSE_ID }}" '{composeId: $id}')" > /dev/null
            
          echo "Deployment triggered. Waiting ${DEPLOY_WAIT_SECONDS}s..."
          sleep ${{ env.DEPLOY_WAIT_SECONDS }}

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Smoke Test
        run: |
          echo "Running full smoke test suite..."
          if [ -f scripts/smoke_test.sh ]; then
            bash scripts/smoke_test.sh https://report-staging.zitian.party
          else
            echo "Smoke test script not found, running basic health check..."
            curl -sf https://report-staging.zitian.party/api/health || exit 1
          fi
          echo "✅ Smoke test passed!"

      - name: Performance Benchmark
        continue-on-error: true  # Don't block deploy, but report issues
        run: |
          echo "Running API performance benchmark..."
          BASE_URL="https://report-staging.zitian.party"
          
          # Test key endpoints
          for endpoint in /api/health /api/ping; do
            response_time=$(curl -sf -w "%{time_total}" -o /dev/null "$BASE_URL$endpoint" 2>/dev/null || echo "failed")
            
            if [ "$response_time" = "failed" ]; then
              echo "::warning::$endpoint - Failed to connect"
            elif (( $(echo "$response_time > 2.0" | bc -l 2>/dev/null || echo 0) )); then
              echo "::warning::$endpoint - Slow: ${response_time}s (> 2s threshold)"
            else
              echo "✅ $endpoint - ${response_time}s"
            fi
          done
          
          echo "Performance benchmark complete."
